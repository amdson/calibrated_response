"""One-shot script to generate solver_debug.ipynb."""
import json, pathlib

def md(*lines):
    return {"cell_type": "markdown", "id": None, "metadata": {}, "source": list(lines)}

def code(*lines):
    return {"cell_type": "code", "execution_count": None, "id": None,
            "metadata": {}, "outputs": [], "source": list(lines)}

cells = [
    md(
        "# Solver Compilation Diagnostics\n",
        "\n",
        "JAX traces and XLA-compiles each `jit`-decorated function on its **first call**,\n",
        "not at `build()` time. All compilation is lazy, so iteration 1 carries a one-time\n",
        "startup cost that never repeats.\n",
        "\n",
        "This notebook isolates each compile step to find what dominates the ~5 min startup:\n",
        "\n",
        "| Step | What compiles | Suspected cost |\n",
        "|------|--------------|----------------|\n",
        "| 1 | `build()` — Python only | < 1 s |\n",
        "| 2 | HMC step fn | 10–60 s |\n",
        "| 3 | Batch features | 10–60 s |\n",
        "| 4 | SMM gradient | **highest suspect** |\n",
        "\n",
        "After the cold-start timings there is a **warm run** section and a **fix comparison**\n",
        "that patches out the inner `@jax.jit` inside `compile_feature_vector`.",
    ),

    code(
        "%load_ext autoreload\n",
        "%autoreload 2\n",
        "\n",
        "import time\n",
        "import jax\n",
        "import jax.numpy as jnp\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "from calibrated_response.models.variable import ContinuousVariable\n",
        "from calibrated_response.models.query import (\n",
        "    ProbabilityEstimate, ConditionalProbabilityEstimate, InequalityProposition,\n",
        ")\n",
        "from calibrated_response.energy_models.markov_random import MarkovRandomField\n",
        "from calibrated_response.maxent_smm.maxent_solver import MaxEntSolver, JAXSolverConfig\n",
        "from calibrated_response.maxent_smm.mcmc import advance_buffer\n",
        "\n",
        'print(f"JAX {jax.__version__} on {jax.devices()}")',
    ),

    md("## Problem Setup\n", "\n", "Same 5-variable chain as `ssm_chain.ipynb`."),

    code(
        "variables = [\n",
        '    ContinuousVariable(name="A", description="Chain", lower_bound=0.0, upper_bound=100.0, unit="%"),\n',
        '    ContinuousVariable(name="B", description="Chain", lower_bound=0.0, upper_bound=100.0, unit="%"),\n',
        '    ContinuousVariable(name="C", description="Chain", lower_bound=0.0, upper_bound=100.0, unit="%"),\n',
        '    ContinuousVariable(name="D", description="Chain", lower_bound=0.0, upper_bound=100.0, unit="%"),\n',
        '    ContinuousVariable(name="E", description="Chain", lower_bound=0.0, upper_bound=100.0, unit="%"),\n',
        "]\n",
        "\n",
        "estimates = [\n",
        "    ProbabilityEstimate(\n",
        '        id="A_prior",\n',
        '        proposition=InequalityProposition(variable="A", variable_type="continuous", threshold=50.0, is_lower_bound=True),\n',
        "        probability=0.9,\n",
        "    ),\n",
        "    ConditionalProbabilityEstimate(\n",
        '        id="AB_prob",\n',
        '        proposition=InequalityProposition(variable="B", variable_type="continuous", threshold=50.0, is_lower_bound=True),\n',
        '        conditions=[InequalityProposition(variable="A", variable_type="continuous", threshold=50.0, is_lower_bound=True)],\n',
        "        probability=0.7,\n",
        "    ),\n",
        "    ConditionalProbabilityEstimate(\n",
        '        id="BC_prob",\n',
        '        proposition=InequalityProposition(variable="C", variable_type="continuous", threshold=50.0, is_lower_bound=True),\n',
        '        conditions=[InequalityProposition(variable="B", variable_type="continuous", threshold=50.0, is_lower_bound=True)],\n',
        "        probability=0.7,\n",
        "    ),\n",
        "    ConditionalProbabilityEstimate(\n",
        '        id="CD_prob",\n',
        '        proposition=InequalityProposition(variable="D", variable_type="continuous", threshold=50.0, is_lower_bound=True),\n',
        '        conditions=[InequalityProposition(variable="C", variable_type="continuous", threshold=50.0, is_lower_bound=True)],\n',
        "        probability=0.7,\n",
        "    ),\n",
        "    ConditionalProbabilityEstimate(\n",
        '        id="DE_prob",\n',
        '        proposition=InequalityProposition(variable="E", variable_type="continuous", threshold=50.0, is_lower_bound=True),\n',
        '        conditions=[InequalityProposition(variable="D", variable_type="continuous", threshold=50.0, is_lower_bound=True)],\n',
        "        probability=0.7,\n",
        "    ),\n",
        "]\n",
        "\n",
        "mrf = MarkovRandomField.from_estimates(variables, estimates, bins_per_var=5)\n",
        "params = mrf.pack_params(mrf.zero_params())\n",
        "energy_fn = mrf.energy_fn_flat\n",
        'print(f"MRF params: {params.shape}")',
    ),

    md(
        "## Step 1 — `solver.build()` (Python-side only)\n",
        "\n",
        "`build()` creates data structures and registers JIT-compiled callables but does\n",
        "**not** trigger any XLA compilation — that is deferred to the first call of each function.",
    ),

    code(
        "from calibrated_response.maxent_smm.features import SoftThresholdFeature, CenteredConditionalFeature\n",
        "from calibrated_response.maxent_smm.variable_spec import VariableSpec, UniformPriorSpec\n",
        "\n",
        "# Minimal feature set (threshold 50/100 = 0.5 in normalised domain)\n",
        "feature_specs = [\n",
        '    SoftThresholdFeature(var_idx=0, threshold=0.5, direction="greater"),\n',
        "    CenteredConditionalFeature(target_var=1, target_threshold=0.5, target_direction=\"greater\",\n",
        "                               cond_var=0, cond_threshold=0.5, cond_direction=\"greater\",\n",
        "                               p_target_given_cond=0.7),\n",
        "    CenteredConditionalFeature(target_var=2, target_threshold=0.5, target_direction=\"greater\",\n",
        "                               cond_var=1, cond_threshold=0.5, cond_direction=\"greater\",\n",
        "                               p_target_given_cond=0.7),\n",
        "    CenteredConditionalFeature(target_var=3, target_threshold=0.5, target_direction=\"greater\",\n",
        "                               cond_var=2, cond_threshold=0.5, cond_direction=\"greater\",\n",
        "                               p_target_given_cond=0.7),\n",
        "    CenteredConditionalFeature(target_var=4, target_threshold=0.5, target_direction=\"greater\",\n",
        "                               cond_var=3, cond_threshold=0.5, cond_direction=\"greater\",\n",
        "                               p_target_given_cond=0.7),\n",
        "]\n",
        "feature_targets = jnp.array([0.9, 0.0, 0.0, 0.0, 0.0], dtype=jnp.float32)\n",
        "var_specs = [VariableSpec(prior=UniformPriorSpec()) for _ in variables]\n",
        "\n",
        "config = JAXSolverConfig(\n",
        "    num_chains=512, num_iterations=5000, mcmc_steps_per_iteration=6,\n",
        "    learning_rate=0.001, l2_regularization=1e-5,\n",
        "    hmc_step_size=0.015, hmc_leapfrog_steps=10, max_bins=15,\n",
        "    seed=42, verbose=False, continuous_prior=\"gaussian\",\n",
        ")\n",
        "\n",
        "t0 = time.perf_counter()\n",
        "solver = MaxEntSolver(config)\n",
        "solver.build(var_specs, feature_specs, feature_targets, energy_fn, params)\n",
        "build_time = time.perf_counter() - t0\n",
        "\n",
        "theta   = solver._theta\n",
        "targets = solver._feature_targets\n",
        "\n",
        'print(f"build() time (Python only, no JIT): {build_time:.3f} s")\n',
        'print(f"  {len(feature_specs)} features | {config.num_chains} chains | {len(variables)} vars")',
    ),

    md(
        "## Step 2 — HMC step function (cold compile)\n",
        "\n",
        "`build_hmc_step_fn` returns `jax.jit(step_fn)`. The first `advance_buffer` triggers\n",
        "tracing + XLA compilation of the leapfrog kernel over all 512 chains.\n",
        "`jax.block_until_ready` forces synchronous completion so the timer captures compile + run.",
    ),

    code(
        "buffer      = solver._buffer\n",
        "hmc_cfg     = solver._hmc_config\n",
        "hmc_step_fn = solver._hmc_step_fn\n",
        "\n",
        'print("Compiling HMC step fn...")\n',
        "t0 = time.perf_counter()\n",
        "buffer = advance_buffer(buffer, theta, n_steps=1, hmc_config=hmc_cfg, step_fn=hmc_step_fn)\n",
        "jax.block_until_ready(buffer.states)\n",
        "hmc_compile_time = time.perf_counter() - t0\n",
        "\n",
        "t0 = time.perf_counter()\n",
        "buffer = advance_buffer(buffer, theta, n_steps=1, hmc_config=hmc_cfg, step_fn=hmc_step_fn)\n",
        "jax.block_until_ready(buffer.states)\n",
        "hmc_warm_time = time.perf_counter() - t0\n",
        "\n",
        'print(f"  cold: {hmc_compile_time:.2f} s")\n',
        'print(f"  warm: {hmc_warm_time*1000:.1f} ms  (overhead {hmc_compile_time/max(hmc_warm_time,1e-9):.0f}x)")',
    ),

    md(
        "## Step 3 — Batch feature function (cold compile)\n",
        "\n",
        "`_batch_feature_fn = jax.jit(jax.vmap(feature_vector_fn))`.\n",
        "If `feature_vector_fn` was itself wrapped with `@jax.jit` inside `compile_feature_vector`,\n",
        "JAX encounters a **JIT barrier** here and must compile a separate kernel for the inner function.",
    ),

    code(
        "states = buffer.states\n",
        'print(f"States shape: {states.shape}  (chains x vars)")\n',
        "\n",
        'print("Compiling batch feature fn...")\n',
        "t0 = time.perf_counter()\n",
        "feats = solver._batch_feature_fn(states)\n",
        "jax.block_until_ready(feats)\n",
        "feat_compile_time = time.perf_counter() - t0\n",
        "\n",
        "t0 = time.perf_counter()\n",
        "feats = solver._batch_feature_fn(states)\n",
        "jax.block_until_ready(feats)\n",
        "feat_warm_time = time.perf_counter() - t0\n",
        "\n",
        'print(f"  cold: {feat_compile_time:.2f} s  -> shape {feats.shape}")\n',
        'print(f"  warm: {feat_warm_time*1000:.1f} ms  (overhead {feat_compile_time/max(feat_warm_time,1e-9):.0f}x)")',
    ),

    md(
        "## Step 4 — SMM gradient (cold compile)\n",
        "\n",
        "`_smm_grad_fn = jax.jit(jax.grad(smm_potential))`. **Prime suspect.**\n",
        "`smm_potential` calls `jax.vmap(feature_vector_fn)` and `jax.vmap(energy_fn)` inside\n",
        "a `jit(grad(...))` trace. If `feature_vector_fn` has an inner `@jax.jit`, that creates\n",
        "a JIT barrier preventing XLA from fusing everything into one kernel.",
    ),

    code(
        'print("Compiling SMM gradient fn...")\n',
        "t0 = time.perf_counter()\n",
        "grad = solver._smm_grad_fn(theta, states, targets)\n",
        "jax.block_until_ready(grad)\n",
        "smm_compile_time = time.perf_counter() - t0\n",
        "\n",
        "t0 = time.perf_counter()\n",
        "grad = solver._smm_grad_fn(theta, states, targets)\n",
        "jax.block_until_ready(grad)\n",
        "smm_warm_time = time.perf_counter() - t0\n",
        "\n",
        'print(f"  cold: {smm_compile_time:.2f} s  -> shape {grad.shape}")\n',
        'print(f"  warm: {smm_warm_time*1000:.1f} ms  (overhead {smm_compile_time/max(smm_warm_time,1e-9):.0f}x)")',
    ),

    md("## Summary"),

    code(
        "total_compile = hmc_compile_time + feat_compile_time + smm_compile_time\n",
        "\n",
        "rows = [\n",
        '    ("build() Python",  build_time,        None),\n',
        '    ("HMC step fn",     hmc_compile_time,  hmc_warm_time),\n',
        '    ("Batch features",  feat_compile_time, feat_warm_time),\n',
        '    ("SMM gradient",    smm_compile_time,  smm_warm_time),\n',
        "]\n",
        "\n",
        'print(f"{\"Step\":<22} {\"Cold (s)\":>10} {\"Warm (ms)\":>10} {\"% of JIT total\":>16}")\n',
        'print("-" * 62)\n',
        "for name, cold, warm in rows:\n",
        "    pct = 100 * cold / max(total_compile, 1e-9)\n",
        '    warm_str = f"{warm*1000:.1f}" if warm is not None else "—"\n',
        '    print(f"{name:<22} {cold:>10.2f} {warm_str:>10} {pct:>15.1f}%")\n',
        'print("-" * 62)\n',
        'print(f"{\"JIT total\":<22} {total_compile:>10.2f}")\n',
        "\n",
        "labels = [\"HMC step fn\", \"Batch features\", \"SMM gradient\"]\n",
        "cold_times = [hmc_compile_time, feat_compile_time, smm_compile_time]\n",
        "fig, ax = plt.subplots(figsize=(7, 3))\n",
        'bars = ax.barh(labels, cold_times, color=["C0", "C1", "C3"])\n',
        'ax.bar_label(bars, fmt="%.1f s", padding=4)\n',
        'ax.set_xlabel("Compile time (s)")\n',
        'ax.set_title("Cold-start XLA compilation time by phase")\n',
        'ax.grid(axis="x", alpha=0.3)\n',
        "plt.tight_layout()\n",
        "plt.show()",
    ),

    md(
        "## Warm iteration timing\n",
        "\n",
        "After all compilations are done, how long does a single full solver iteration take?",
    ),

    code(
        "N_WARM = 10\n",
        "t_hmc, t_feat, t_grad, t_total = [], [], [], []\n",
        "\n",
        "for _ in range(N_WARM):\n",
        "    t_iter = time.perf_counter()\n",
        "\n",
        "    t0 = time.perf_counter()\n",
        "    buffer = advance_buffer(buffer, theta, n_steps=config.mcmc_steps_per_iteration,\n",
        "                            hmc_config=hmc_cfg, step_fn=hmc_step_fn)\n",
        "    jax.block_until_ready(buffer.states)\n",
        "    t_hmc.append(time.perf_counter() - t0)\n",
        "\n",
        "    t0 = time.perf_counter()\n",
        "    feats = solver._batch_feature_fn(buffer.states)\n",
        "    jax.block_until_ready(feats)\n",
        "    t_feat.append(time.perf_counter() - t0)\n",
        "\n",
        "    t0 = time.perf_counter()\n",
        "    g = solver._smm_grad_fn(theta, buffer.states, targets)\n",
        "    jax.block_until_ready(g)\n",
        "    t_grad.append(time.perf_counter() - t0)\n",
        "\n",
        "    t_total.append(time.perf_counter() - t_iter)\n",
        "\n",
        "ms = lambda ts: np.mean(ts) * 1000\n",
        'print(f"Warm iteration breakdown (mean over {N_WARM} runs, {config.mcmc_steps_per_iteration} HMC steps/iter):")\n',
        'print(f"  HMC advance:    {ms(t_hmc):.1f} ms")\n',
        'print(f"  Batch features: {ms(t_feat):.1f} ms")\n',
        'print(f"  SMM gradient:   {ms(t_grad):.1f} ms")\n',
        'print(f"  Total:          {ms(t_total):.1f} ms/iter")\n',
        'print(f"  => {config.num_iterations} iters ~ {ms(t_total)*config.num_iterations/60000:.1f} min")',
    ),

    md(
        "## Fix: patch out the inner `@jax.jit` in `compile_feature_vector`\n",
        "\n",
        "Re-create the feature function **without** an inner `jax.jit` and re-compile the SMM grad.\n",
        "If the JIT-barrier hypothesis is correct, step-4 compile time should drop significantly.",
    ),

    code(
        "from calibrated_response.maxent_smm.features import compile_feature\n",
        "\n",
        "# Non-JIT feature vector — same logic as compile_feature_vector but without @jax.jit\n",
        "_fns = [compile_feature(s) for s in feature_specs]\n",
        "def feature_vector_no_jit(x):\n",
        "    return jnp.array([fn(x) for fn in _fns])\n",
        "\n",
        "# Patch solver in-place\n",
        "solver._feature_vector_fn = feature_vector_no_jit\n",
        "solver._batch_feature_fn  = jax.jit(jax.vmap(feature_vector_no_jit))\n",
        "solver.compile_grad()  # re-creates _smm_grad_fn with the patched fn\n",
        "\n",
        'print("=== Patched (no inner @jax.jit on feature vector) ===")\n',
        "\n",
        "t0 = time.perf_counter()\n",
        "feats2 = solver._batch_feature_fn(states)\n",
        "jax.block_until_ready(feats2)\n",
        "feat2_compile = time.perf_counter() - t0\n",
        'print(f"  Batch features compile: {feat2_compile:.2f} s")\n',
        "\n",
        "t0 = time.perf_counter()\n",
        "grad2 = solver._smm_grad_fn(theta, states, targets)\n",
        "jax.block_until_ready(grad2)\n",
        "smm2_compile = time.perf_counter() - t0\n",
        'print(f"  SMM grad compile:       {smm2_compile:.2f} s")\n',
        "\n",
        "print()\n",
        'print("=== Before vs After ===")\n',
        "def _d(before, after):\n",
        "    diff = after - before\n",
        '    return f"{after:.2f} s  ({diff:+.2f} s, {\'faster\' if diff < 0 else \'slower\'})"\n',
        'print(f"  Batch features:  {feat_compile_time:.2f} s  ->  {_d(feat_compile_time, feat2_compile)}")\n',
        'print(f"  SMM gradient:    {smm_compile_time:.2f} s  ->  {_d(smm_compile_time, smm2_compile)}")\n',
        "saving = (feat_compile_time + smm_compile_time) - (feat2_compile + smm2_compile)\n",
        'print(f"  Combined saving: {saving:.2f} s")',
    ),

    md(
        "## Interpretation guide\n",
        "\n",
        "| Result | Conclusion |\n",
        "|--------|------------|\n",
        "| SMM grad >> HMC + features | JIT barrier is the bottleneck — apply fix permanently |\n",
        "| HMC compile dominates | Try fewer `hmc_leapfrog_steps` or fewer `num_chains` |\n",
        "| Fix shows much faster SMM compile | Remove `@jax.jit` from `compile_feature_vector` |\n",
        "| Fix shows similar times | JIT barrier not the cause; profile MRF param dim or feature count |\n",
        "\n",
        "If the fix works, the change in\n",
        "[`calibrated_response/maxent_smm/features.py`](../calibrated_response/maxent_smm/features.py)\n",
        "is to remove `@jax.jit` from the `_feature_vector` closure inside `compile_feature_vector`\n",
        "(the outer `_batch_feature_fn = jax.jit(jax.vmap(...))` remains as the JIT boundary).",
    ),
]

# Assign sequential ids
for i, cell in enumerate(cells):
    cell["id"] = f"cell_{i:02d}"

nb = {
    "cells": cells,
    "metadata": {
        "kernelspec": {"display_name": "Python 3", "language": "python", "name": "python3"},
        "language_info": {"name": "python", "version": "3.11.0"},
    },
    "nbformat": 4,
    "nbformat_minor": 5,
}

out = pathlib.Path(__file__).parent / "solver_debug.ipynb"
out.write_text(json.dumps(nb, indent=1), encoding="utf-8")
print(f"Written {out}  ({out.stat().st_size} bytes)")
